---
title: "Introduction to Importing Data in R"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = F)
```

# 1. Importing data from flat files with utils
## read.csv

The `utils` package, which is automatically loaded in your R session on startup, can import CSV files with the <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.csv()`</a> function.

In this exercise, you'll be working with <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/swimming_pools.csv" target="_blank" rel="noopener noreferrer">`swimming_pools.csv`</a>; it contains data on swimming pools in Brisbane, Australia (Source: <a href="https://data.gov.au/dataset/swimming-pools-brisbane-city-council" target="_blank" rel="noopener noreferrer">data.gov.au</a>). The file contains the column names in the first row. It uses a comma to separate values within rows. 

Type <a href="http://www.rdocumentation.org/packages/base/functions/list.files" target="_blank" rel="noopener noreferrer">`dir()`</a> in the console to list the files in your working directory. You'll see that it contains `swimming_pools.csv`, so you can start straight away.


**Instructions:**

* Use <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.csv()`</a> to import `"swimming_pools.csv"` as a data frame with the name `pools`.
* Print the structure of `pools` using <a href="http://www.rdocumentation.org/packages/utils/functions/str" target="_blank" rel="noopener noreferrer">`str()`</a>.

**Solution:**

```{r,eval=TRUE}
# Import swimming_pools.csv: pools
pools <- read.csv("data/swimming_pools.csv")

# Print the structure of pools
str(pools)
```



## stringsAsFactors

With `stringsAsFactors`, you can tell R whether it should convert strings in the flat file to factors. 

For all importing functions in the `utils` package, this argument is `TRUE`, which means that you import strings as factors. This only makes sense if the strings you import represent categorical variables in R. If you set `stringsAsFactors` to `FALSE`, the data frame columns corresponding to strings in your text file will be `character`.

You'll again be working with the <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/swimming_pools.csv" target="_blank" rel="noopener noreferrer">`swimming_pools.csv`</a> file. It contains two columns (`Name` and `Address`), which shouldn't be factors.


**Instructions:**

* Use `read.csv()` to import the data in <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/swimming_pools.csv" target="_blank" rel="noopener noreferrer">`"swimming_pools.csv"`</a> as a data frame called `pools`; make sure that strings are imported as characters, not as factors.
* Using <a href="http://www.rdocumentation.org/packages/utils/functions/str" target="_blank" rel="noopener noreferrer">`str()`</a>, display the structure of the dataset and check that you indeed get character vectors instead of factors.

**Solution:**

```{r,eval=TRUE}
# Import swimming_pools.csv correctly: pools
pools <- read.csv("data/swimming_pools.csv", stringsAsFactors = F)

# Check the structure of pools
str(pools)
```



## Any changes?

Consider the code below that loads data from `swimming_pools.csv` in two distinct ways:


```{r}
# Option A
pools <- read.csv("swimming_pools.csv", stringsAsFactors = TRUE)

# Option B
pools <- read.csv("swimming_pools.csv", stringsAsFactors = FALSE)
```

How many variables in the resulting `pools` data frame have different types if you specify the `stringsAsFactors` argument differently?

The <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/swimming_pools.csv" target="_blank" rel="noopener noreferrer">`swimming_pools.csv`</a> file is available in your current working directory so you can experiment in the console.


**Possible Answers:**

:white_large_square: Just one: Name.<br>
:white_check_mark: Two variables: Name and Address.<br>
:white_large_square: Three columns: all but Longitude.<br>
:white_large_square: All four of them!<br>


## read.delim

Aside from `.csv` files, there are also the `.txt` files which are basically text files. You can import these functions with <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.delim()`</a>. By default, it sets the `sep` argument to `"\t"` (fields in a record are delimited by tabs) and the `header` argument to `TRUE` (the first row contains the field names). 

In this exercise, you will import <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt" target="_blank" rel="noopener noreferrer">`hotdogs.txt`</a>, containing information on sodium and calorie levels in different hotdogs (Source: <a href="http://wiki.stat.ucla.edu/socr/index.php/SOCR_012708_ID_Data_HotDogs" target="_blank" rel="noopener noreferrer">UCLA</a>). The dataset has 3 variables, but the variable names are *not* available in the first line of the file. The file uses tabs as field separators.


**Instructions:**

* Import the data in `"hotdogs.txt"` with <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.delim()`</a>. Call the resulting data frame `hotdogs`. The variable names are **not** on the first line, so make sure to set the `header` argument appropriately.
* Call <a href="http://www.rdocumentation.org/packages/base/functions/summary" target="_blank" rel="noopener noreferrer">`summary()`</a> on `hotdogs`. This will print out some summary statistics about all variables in the data frame.

**Solution:**

```{r,eval=TRUE}
# Import hotdogs.txt: hotdogs
hotdogs <- read.delim("data/hotdogs.txt", header = F)

# Summarize hotdogs
summary(hotdogs)
```



## read.table

If you're dealing with more exotic flat file formats, you'll want to use <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.table()`</a>. It's the most basic importing function; you can specify tons of different arguments in this function. Unlike <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.csv()`</a> and <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.delim()`</a>, the `header` argument defaults to `FALSE` and the `sep` argument is `""` by default.

Up to you again! The data is still <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt" target="_blank" rel="noopener noreferrer">`hotdogs.txt`</a>. It has no column names in the first row, and the field separators are tabs. This time, though, the file is in the `data` folder inside your current working directory. A variable `path` with the location of this file is already coded for you.


**Instructions:**

* Finish the `read.table()` call that's been prepared for you. Use the `path` variable, and make sure to set `sep` correctly.
* Call `head()` on `hotdogs`; this will print the first 6 observations in the data frame.

**Solution:**

```{r,eval=TRUE}
# Path to the hotdogs.txt file: path
path <- file.path("data", "hotdogs.txt")

# Import the hotdogs.txt file: hotdogs
hotdogs <- read.table(path, 
                      sep = "\t", 
                      col.names = c("type", "calories", "sodium"))

# Call head() on hotdogs
head(hotdogs)
```



## Arguments

Lily and Tom are having an argument because they want to share a hot dog but they can't seem to agree on which one to choose. After some time, they simply decide that they will have one each. Lily wants to have the one with the fewest calories while Tom wants to have the one with the most sodium.

Next to `calories` and `sodium`, the hotdogs have one more variable: `type`. This can be one of three things: `Beef`, `Meat`, or `Poultry`, so a categorical variable: a factor is fine.


**Instructions:**

* Finish the `read.delim()` call to import the data in <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt" target="_blank" rel="noopener noreferrer">`"hotdogs.txt"`</a>. It's a tab-delimited file without names in the first row.
* The code that selects the observation with the lowest calorie count and stores it in the variable `lily` is already available. It uses the function <a href="http://www.rdocumentation.org/packages/base/functions/which.min" target="_blank" rel="noopener noreferrer">`which.min()`</a>, that returns the index the smallest value in a vector.
* Do a similar thing for Tom: select the observation with the *most sodium* and store it in `tom`. Use <a href="http://www.rdocumentation.org/packages/base/functions/which.min" target="_blank" rel="noopener noreferrer">`which.max()`</a> this time.
* Finally, print both the observations `lily` and `tom`.

**Solution:**

```{r,eval=TRUE}
# Finish the read.delim() call
hotdogs <- read.delim("data/hotdogs.txt", header = F, col.names = c("type", "calories", "sodium"))

# Select the hot dog with the least calories: lily
lily <- hotdogs[which.min(hotdogs$calories), ]

# Select the observation with the most sodium: tom
tom <- hotdogs[which.max(hotdogs$sodium),]

# Print lily and tom
lily
tom
```



## Column classes

Next to column names, you can also specify the column types or column classes of the resulting data frame. You can do this by setting the `colClasses` argument to a vector of strings representing classes:

```{r}
read.delim("data/my_file.txt", 
           colClasses = c("character",
                          "numeric",
                          "logical"))
```

This approach can be useful if you have some columns that should be factors and others that should be characters. You don't have to bother with `stringsAsFactors` anymore; just state for each column what the class should be.

If a column is set to `"NULL"` in the `colClasses` vector, this column will be skipped and will not be loaded into the data frame.


**Instructions:**

* The `read.delim()` call from before is already included and creates the `hotdogs` data frame. Go ahead and display the structure of `hotdogs`.
* **Edit** the second <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.delim()`</a> call. Assign the correct vector to the `colClasses` argument. `NA` should be replaced with a character vector: `c("factor", "NULL", "numeric")`.
* Display the structure of `hotdogs2` and look for the difference.

**Solution:**

```{r,eval=TRUE}
# Previous call to import hotdogs.txt
hotdogs <- read.delim("data/hotdogs.txt", header = FALSE, col.names = c("type", "calories", "sodium"))

# Display structure of hotdogs
str(hotdogs)
```

```{r}
# Edit the colClasses argument to import the data correctly: hotdogs2
hotdogs2 <- read.delim("hotdogs.txt", header = FALSE, 
                       col.names = c("type", "calories", "sodium"),
                       colClasses = c("factor", "NULL", "numeric"))


# Display structure of hotdogs2
str(hotdogs2)
```


# 2. readr & data.table
## read_csv

CSV files can be imported with <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim" target="_blank" rel="noopener noreferrer">`read_csv()`</a>. It's a wrapper function around <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim" target="_blank" rel="noopener noreferrer">`read_delim()`</a> that handles all the details for you. For example, it will assume that the first row contains the column names.

The dataset you'll be working with here is <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv" target="_blank" rel="noopener noreferrer">`potatoes.csv`</a>. It gives information on the impact of storage period and cooking on potatoes' flavor. It uses commas to delimit fields in a record, and contains column names in the first row. The file is available in your workspace. Remember that you can inspect your workspace with `dir()`.


**Instructions:**

* Load the `readr` package with <a href="http://www.rdocumentation.org/packages/base/functions/library" target="_blank" rel="noopener noreferrer">`library()`</a>. You **do not** need to install the package, it is already installed on DataCamp's servers. 
* Import `"potatoes.csv"` using `read_csv()`. Assign the resulting data frame to the variable `potatoes`.

**Solution:**

```{r,eval=TRUE}
# Load the readr package
library(readr)

# Import potatoes.csv with read_csv(): potatoes
potatoes <- read_csv("data/potatoes.csv")
```



## read_tsv

Where you use `read_csv()` to easily read in CSV files, you use <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim" target="_blank" rel="noopener noreferrer">`read_tsv()`</a> to easily read in TSV files. TSV is short for tab-separated values.

This time, the potatoes data comes in the form of a tab-separated values file; <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt" target="_blank" rel="noopener noreferrer">`potatoes.txt`</a> is available in your workspace. In contrast to `potatoes.csv`, this file does **not** contain columns names in the first row, though.

There's a vector `properties` that you can use to specify these column names manually.


**Instructions:**

* Use `read_tsv()` to import the potatoes data from `potatoes.txt` and store it in the data frame `potatoes`. In addition to the path to the file, you'll also have to specify the `col_names` argument; you can use the `properties` vector for this.
* Call `head()` on `potatoes` to show the first observations of your dataset.

**Solution:**

```{r,eval=TRUE}
# Column names
properties <- c("area", "temp", "size", "storage", "method",
                "texture", "flavor", "moistness")

# Import potatoes.txt: potatoes
potatoes <- read_tsv("data/potatoes.txt" , col_names = properties)

# Call head() on potatoes
head(potatoes)
```



## read_delim

Just as <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.table()`</a> was the main `utils` function, <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim" target="_blank" rel="noopener noreferrer">`read_delim()`</a> is the main `readr` function.

<a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim" target="_blank" rel="noopener noreferrer">`read_delim()`</a> takes two mandatory arguments:


* `file`: the file that contains the data
* `delim`: the character that separates the values in the data file

You'll again be working <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt" target="_blank" rel="noopener noreferrer">`potatoes.txt`</a>; the file uses tabs (`"\t"`) to delimit values and does **not** contain column names in its first line. It's available in your working directory so you can start right away. As before, the vector `properties` is available to set the `col_names`.


**Instructions:**

* Import all the data in <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt" target="_blank" rel="noopener noreferrer">`"potatoes.txt"`</a> using <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim" target="_blank" rel="noopener noreferrer">`read_delim()`</a>; store the resulting data frame in `potatoes`.
* Print out `potatoes`.

**Solution:**

```{r}
# Column names
properties <- c("area", "temp", "size", "storage", "method",
                "texture", "flavor", "moistness")

# Import potatoes.txt using read_delim(): potatoes
potatoes <- read_delim("data/potatoes.txt", delim = "\t", col_names = properties)

# Print out potatoes
potatoes
```



## skip and n_max

Through `skip` and `n_max` you can control *which part* of your flat file you're actually importing into R.


* `skip` specifies the number of lines you're ignoring in the flat file before actually starting to import data.
* `n_max` specifies the number of lines you're actually importing.

Say for example you have a CSV file with 20 lines, and set `skip = 2` and `n_max = 3`, you're only reading in lines 3, 4 and 5 of the file.

Watch out: Once you `skip` some lines, you also skip the first line that can contain column names!

<a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt" target="_blank" rel="noopener noreferrer">`potatoes.txt`</a>, a flat file with tab-delimited records and without column names, is available in your workspace.


**Instructions:**

Finish the first <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim" target="_blank" rel="noopener noreferrer">`read_tsv()`</a> call to import observations 7, 8, 9, 10 and 11 from `potatoes.txt`.


**Solution:**

```{r,eval=TRUE}
# Column names
properties <- c("area", "temp", "size", "storage", "method",
                "texture", "flavor", "moistness")

# Import 5 observations from potatoes.txt: potatoes_fragment
potatoes_fragment <- read_tsv("data/potatoes.txt", skip = 6, n_max = 5, col_names = properties)
```



## col_types

You can also specify which types the columns in your imported data frame should have. You can do this with `col_types`. If set to `NULL`, the default, functions from the `readr` package will try to find the correct types themselves. You can manually set the types with a string, where each character denotes the class of the column: `c`haracter, `d`ouble, `i`nteger and `l`ogical. `_` skips the column as a whole.

<a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt" target="_blank" rel="noopener noreferrer">`potatoes.txt`</a>, a flat file with tab-delimited records and without column names, is again available in your workspace.


**Instructions:**

* In the second <a href="http://www.rdocumentation.org/packages/readr/versions/1.0.0/topics/read_delim" target="_blank" rel="noopener noreferrer">`read_tsv()`</a> call, edit the `col_types` argument to import *all* columns as characters (`c`). Store the resulting data frame in `potatoes_char`.
* Print out the structure of `potatoes_char` and verify whether all column types are `chr`, short for `character`.

**Solution:**

```{r,eval=TRUE}
# Column names
properties <- c("area", "temp", "size", "storage", "method",
                "texture", "flavor", "moistness")

# Import all data, but force all columns to be character: potatoes_char
potatoes_char <- read_tsv("data/potatoes.txt", col_types = "cccccccc", col_names = properties)

# Print out structure of potatoes_char
str(potatoes_char)
```



## col_types with collectors

Another way of setting the types of the imported columns is using **collectors**. Collector functions can be passed in a <a href="http://www.rdocumentation.org/packages/base/functions/list" target="_blank" rel="noopener noreferrer">`list()`</a> to the `col_types` argument of `read_` functions to tell them how to interpret values in a column.

For a complete list of collector functions, you can take a look at the <a href="https://www.rdocumentation.org/packages/readr/topics/collector" target="_blank" rel="noopener noreferrer">`collector`</a> documentation. For this exercise you will need two collector functions:


* `col_integer()`: the column should be interpreted as an integer.
* `col_factor(levels, ordered = FALSE)`: the column should be interpreted as a factor with `levels`.

In this exercise, you will work with <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt" target="_blank" rel="noopener noreferrer">`hotdogs.txt`</a>, which is a tab-delimited file without column names in the first row.


**Instructions:**

* `hotdogs` is created for you without setting the column types. Inspect its summary using the <a href="http://www.rdocumentation.org/packages/base/functions/summary" target="_blank" rel="noopener noreferrer">`summary()`</a> function.
* Two collector functions are defined for you: `fac` and `int`. Have a look at them, do you understand what they're collecting?
* In the second `read_tsv()` call, edit the `col_types` argument: Pass a `list()` with the elements `fac`, `int` and `int`, so the first column is imported as a factor, and the second and third column as integers.
* Create a <a href="http://www.rdocumentation.org/packages/base/functions/summary" target="_blank" rel="noopener noreferrer">`summary()`</a> of `hotdogs_factor`. Compare this to the summary of `hotdogs`.

**Solution:**

```{r,eval=TRUE}
# Import without col_types
hotdogs <- read_tsv("data/hotdogs.txt", col_names = c("type", "calories", "sodium"))

# Display the summary of hotdogs
summary(hotdogs)
```

```{r,eval=TRUE}
# The collectors you will need to import the data
fac <- col_factor(levels = c("Beef", "Meat", "Poultry"))
int <- col_integer()

# Edit the col_types argument to import the data correctly: hotdogs_factor
hotdogs_factor <- read_tsv("data/hotdogs.txt",
                           col_names = c("type", "calories", "sodium"),
                           col_types = list(fac, int, int))

# Display the summary of hotdogs_factor
summary(hotdogs_factor)
```



## fread

You still remember how to use <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.table()`</a>, right? Well, <a href="http://www.rdocumentation.org/packages/data.table/functions/fread" target="_blank" rel="noopener noreferrer">`fread()`</a> is a function that does the same job with very similar arguments. It is extremely easy to use and blazingly fast! Often, simply specifying the path to the file is enough to successfully import your data.

Don't take our word for it, try it yourself! You'll be working with the <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv" target="_blank" rel="noopener noreferrer">`potatoes.csv`</a> file, that's available in your workspace. Fields are delimited by commas, and the first line contains the column names.


**Instructions:**

* Use <a href="http://www.rdocumentation.org/packages/base/functions/library" target="_blank" rel="noopener noreferrer">`library()`</a> to load (NOT install) the `data.table` package. You **do not** need to install the package, it is already installed on DataCamp's servers. 
* Import `"potatoes.csv"` with <a href="http://www.rdocumentation.org/packages/data.table/functions/fread" target="_blank" rel="noopener noreferrer">`fread()`</a>. Simply pass it the file path and see if it worked. Store the result in a variable `potatoes`.
* Print out `potatoes`.

**Solution:**

```{r,eval=TRUE}
# load the data.table package
library(data.table)

# Import potatoes.csv with fread(): potatoes
potatoes <- fread("data/potatoes.csv")

# Print out potatoes
potatoes
```



## fread: more advanced use

Now that you know the basics about <a href="http://www.rdocumentation.org/packages/data.table/functions/fread" target="_blank" rel="noopener noreferrer">`fread()`</a>, you should know about two arguments of the function: `drop` and `select`, to drop or select variables of interest.

Suppose you have a dataset that contains 5 variables and you want to keep the first and fifth variable, named "a" and "e". The following options will all do the trick:


```{r}
fread("path/to/file.txt", drop = 2:4)
fread("path/to/file.txt", select = c(1, 5))
fread("path/to/file.txt", drop = c("b", "c", "d"))
fread("path/to/file.txt", select = c("a", "e"))
```

Let's stick with potatoes since we're particularly fond of them here at DataCamp. The data is again available in the file <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv" target="_blank" rel="noopener noreferrer">`potatoes.csv`</a>, containing comma-separated records.


**Instructions:**

* Using <a href="http://www.rdocumentation.org/packages/data.table/functions/fread" target="_blank" rel="noopener noreferrer">`fread()`</a> and `select` or `drop` as arguments, only import the `texture` and `moistness` columns of the flat file. They correspond to the columns 6 and 8 in `"potatoes.csv"`. Store the result in a variable `potatoes`.
* <a href="http://www.rdocumentation.org/packages/graphics/functions/plot" target="_blank" rel="noopener noreferrer">`plot()`</a> 2 columns of the `potatoes` data frame: `texture` on the x-axis, `moistness` on the y-axis. Use the dollar sign notation twice. Feel free to name your axes and plot.

**Solution:**

```{r,eval=TRUE}
# Import columns 6 and 8 of potatoes.csv: potatoes
potatoes <- fread("data/potatoes.csv", select = c("texture", "moistness"))

# Plot texture (x) and moistness (y) of potatoes
plot(potatoes$texture, potatoes$moistness)
```



## Dedicated classes

You might have noticed that the <a href="http://www.rdocumentation.org/packages/data.table/functions/fread" target="_blank" rel="noopener noreferrer">`fread()`</a> function produces data frames that look slightly different when you print them out. That's because another class named `data.table` is assigned to the resulting data frames. The printout of such `data.table` objects is different. Does something similar happen with the data frames generated by `readr`?

In your current working directory, we prepared the <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv" target="_blank" rel="noopener noreferrer">`potatoes.csv`</a> file. The packages `data.table` and `readr` are both loaded, so you can experiment straight away.

Which of the following statements is true?

:white_large_square: `fread()` creates an object whose only class is data.table class. `read_csv()` creates an object with class `tbl_df.`
:white_large_square: The class of the result of `fread()` is only data.table. That of the result of `read_csv()` is both `tbl_df` and `tbl`.
:white_check_mark: The class of the result of `fread()` is both `data.table` and `data.frame`. `read_csv()` creates an object with three classes: `tbl_df`, `tbl` and `data.frame`.
:white_large_square: `fread()` creates an object of the `data.table` class, while `read_csv()` simply generates a `data.frame`, nothing more.

# 3. Importing Excel data
## List the sheets of an Excel file

Before you can start importing from Excel, you should find out which sheets are available in the workbook. You can use the <a href="https://cran.r-project.org/web/packages/readxl/readxl.pdf" target="_blank" rel="noopener noreferrer">`excel_sheets()`</a> function for this.

You will find the Excel file <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop.xlsx`</a> in your working directory (type <a href="http://www.rdocumentation.org/packages/base/functions/list.files" target="_blank" rel="noopener noreferrer">`dir()`</a> to see it). This dataset contains urban population metrics for practically all countries in the world throughout time (Source: <a href="http://www.gapminder.org/" target="_blank" rel="noopener noreferrer">Gapminder</a>). It contains three sheets for three different time periods. In each sheet, the first row contains the column names.


**Instructions:**

* Load the `readxl` package using <a href="http://www.rdocumentation.org/packages/base/functions/library" target="_blank" rel="noopener noreferrer">`library()`</a>. It's already installed on DataCamp's servers.
* Use <a href="https://cran.r-project.org/web/packages/readxl/readxl.pdf" target="_blank" rel="noopener noreferrer">`excel_sheets()`</a> to print out the names of the sheets in `urbanpop.xlsx`.

**Solution:**

```{r,eval=TRUE}
# Load the readxl package
library("readxl")

# Print the names of all worksheets
excel_sheets("data/urbanpop.xlsx")
```



## Import an Excel sheet

Now that you know the names of the sheets in the Excel file you want to import, it is time to import those sheets into R. You can do this with the <a href="https://cran.r-project.org/web/packages/readxl/readxl.pdf" target="_blank" rel="noopener noreferrer">`read_excel()`</a> function. Have a look at this recipe:


```{r}
data <- read_excel("data.xlsx", sheet = "my_sheet")
```

This call simply imports the sheet with the name `"my_sheet"` from the `"data.xlsx"` file. You can also pass a number to the `sheet` argument; this will cause <a href="https://cran.r-project.org/web/packages/readxl/readxl.pdf" target="_blank" rel="noopener noreferrer">`read_excel()`</a> to import the sheet with the given sheet number. `sheet = 1` will import the first sheet, `sheet = 2` will import the second sheet, and so on.

In this exercise, you'll continue working with the <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop.xlsx`</a> file.


**Instructions:**

* The code to import the first and second sheets is already included. Can you add a command to also import the third sheet, and store the resulting data frame in `pop_3`?
* Store the data frames `pop_1`, `pop_2` and `pop_3` in a list, that you call `pop_list`.
* Display the structure of `pop_list`.

**Solution:**

```{r,eval=TRUE}
# Read the sheets, one by one
pop_1 <- read_excel("data/urbanpop.xlsx", sheet = 1)
pop_2 <- read_excel("data/urbanpop.xlsx", sheet = 2)
pop_3 <- read_excel("data/urbanpop.xlsx", sheet = 3)

# Put pop_1, pop_2 and pop_3 in a list: pop_list
pop_list <- list(pop_1, pop_2, pop_3)

# Display the structure of pop_list
str(pop_list)
```



## Reading a workbook

In the previous exercise you generated a list of three Excel sheets that you imported. However, loading in every sheet manually and then merging them in a list can be quite tedious. Luckily, you can automate this with <a href="http://www.rdocumentation.org/packages/base/functions/lapply" target="_blank" rel="noopener noreferrer">`lapply()`</a>. If you have no experience with <a href="http://www.rdocumentation.org/packages/base/functions/lapply" target="_blank" rel="noopener noreferrer">`lapply()`</a>, feel free to take <a href="https://campus.datacamp.com/courses/intermediate-r/chapter-4-the-apply-family?ex=1" target="_blank" rel="noopener noreferrer">Chapter 4 of the Intermediate R course</a>.

Have a look at the example code below:

```{r}
my_workbook <- lapply(excel_sheets("data.xlsx"),
                      read_excel,
                      path = "data.xlsx")
```

The <a href="https://cran.r-project.org/web/packages/readxl/readxl.pdf" target="_blank" rel="noopener noreferrer">`read_excel()`</a> function is called multiple times on the `"data.xlsx"` file and each sheet is loaded in one after the other. The result is a list of data frames, each data frame representing one of the sheets in `data.xlsx`.

You're still working with the <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop.xlsx`</a> file.


**Instructions:**

* Use <a href="http://www.rdocumentation.org/packages/base/functions/lapply" target="_blank" rel="noopener noreferrer">`lapply()`</a> in combination with <a href="https://cran.r-project.org/web/packages/readxl/readxl.pdf" target="_blank" rel="noopener noreferrer">`excel_sheets()`</a> and <a href="https://cran.r-project.org/web/packages/readxl/readxl.pdf" target="_blank" rel="noopener noreferrer">`read_excel()`</a> to read all the Excel sheets in `"urbanpop.xlsx"`. Name the resulting list `pop_list`.
* Print the structure of `pop_list`.

**Solution:**

```{r}
# Read all Excel sheets with lapply(): pop_list
pop_list <- lapply(excel_sheets("data/urbanpop.xlsx"), read_excel, path = "data/urbanpop.xlsx")

# Display the structure of pop_list
str(pop_list)
```



## The col_names argument

Apart from `path` and `sheet`, there are several other arguments you can specify in <a href="https://cran.r-project.org/web/packages/readxl/readxl.pdf" target="_blank" rel="noopener noreferrer">`read_excel()`</a>. One of these arguments is called `col_names`.

By default it is `TRUE`, denoting whether the first row in the Excel sheets contains the column names. If this is not the case, you can set `col_names` to `FALSE`. In this case, R will choose column names for you. You can also choose to set `col_names` to a character vector with names for each column. It works exactly the same as in the `readr` package.

You'll be working with the <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop_nonames.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop_nonames.xlsx`</a> file. It contains the same data as <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop.xlsx`</a> but has no column names in the first row of the excel sheets.


**Instructions:**

* Import the *first* Excel sheet of `"urbanpop_nonames.xlsx"` and store the result in `pop_a`. Have R set the column names of the resulting data frame itself.
* Import the first Excel sheet of `urbanpop_nonames.xlsx`; this time, use the `cols` vector that has already been prepared for you to specify the column names. Store the resulting data frame in `pop_b`.
* Print out the summary of `pop_a`.
* Print out the summary of `pop_b`. Can you spot the difference with the other summary?

**Solution:**

```{r,eval=TRUE}
# Import the first Excel sheet of urbanpop_nonames.xlsx (R gives names): pop_a
pop_a <- read_excel("data/urbanpop_nonames.xlsx", col_names = F)

# Import the first Excel sheet of urbanpop_nonames.xlsx (specify col_names): pop_b
cols <- c("country", paste0("year_", 1960:1966))
pop_b <- read_excel("data/urbanpop_nonames.xlsx", col_names = cols)

# Print the summary of pop_a
summary(pop_a)

# Print the summary of pop_b
summary(pop_b)
```



## The skip argument

Another argument that can be very useful when reading in Excel files that are less tidy, is `skip`. With `skip`, you can tell R to ignore a specified number of rows inside the Excel sheets you're trying to pull data from. Have a look at this example:


```{r}
read_excel("data.xlsx", skip = 15)
```

In this case, the first 15 rows in the first sheet of `"data.xlsx"` are ignored.

If the first row of this sheet contained the column names, this information will also be ignored by `readxl`. Make sure to set `col_names` to `FALSE` or manually specify column names in this case!

The file <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop.xlsx`</a> is available in your directory; it has column names in the first rows.


**Instructions:**

* Import the *second* sheet of `"urbanpop.xlsx"`, but skip the first 21 rows. Make sure to set `col_names = FALSE`. Store the resulting data frame in a variable `urbanpop_sel`.
* Select the first observation from `urbanpop_sel` and print it out.

**Solution:**

```{r,eval=TRUE}
# Import the second sheet of urbanpop.xlsx, skipping the first 21 rows: urbanpop_sel
urbanpop_sel <- read_excel("data/urbanpop.xlsx", sheet = 2, col_names = F, skip = 21)

# Print out the first observation from urbanpop_sel
urbanpop_sel[1,]
```



## Import a local file

In this part of the chapter you'll learn how to import `.xls` files using the `gdata` package. Similar to the `readxl` package, you can import single Excel sheets from Excel sheets to start your analysis in R.

You'll be working with the <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xls" target="_blank" rel="noopener noreferrer">`urbanpop.xls`</a> dataset, the `.xls` version of the Excel file you've been working with before. It's available in your current working directory.


**Instructions:**

* Load the `gdata` package with <a href="http://www.rdocumentation.org/packages/base/functions/library" target="_blank" rel="noopener noreferrer">`library()`</a>. `gdata` and Perl are already installed on DataCamp's Servers.
* Import the second sheet, named `"1967-1974"`, of `"urbanpop.xls"` with <a href="http://www.rdocumentation.org/packages/gdata/functions/read.xls" target="_blank" rel="noopener noreferrer">`read.xls()`</a>. Store the resulting data frame as `urban_pop`.
* Print the first 11 observations of `urban_pop` with <a href="http://www.rdocumentation.org/packages/utils/functions/head" target="_blank" rel="noopener noreferrer">`head()`</a>.

**Solution:**

```{r,eval=TRUE}
# Load the gdata package
library("gdata")

# Import the second sheet of urbanpop.xls: urban_pop
urban_pop <- read.xls("data/urbanpop.xls", sheet = "1967-1974")

# Print the first 11 observations using head()
head(urban_pop, n = 11)
```



## read.xls() wraps around read.table()

Remember how <a href="http://www.rdocumentation.org/packages/gdata/functions/read.xls" target="_blank" rel="noopener noreferrer">`read.xls()`</a> actually works? It basically comes down to two steps: converting the Excel file to a `.csv` file using a Perl script, and then reading that `.csv` file with the <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.csv()`</a> function that is loaded by default in R, through the `utils` package.

This means that all the options that you can specify in <a href="http://www.rdocumentation.org/packages/utils/functions/read.table" target="_blank" rel="noopener noreferrer">`read.csv()`</a>, can also be specified in <a href="http://www.rdocumentation.org/packages/gdata/functions/read.xls" target="_blank" rel="noopener noreferrer">`read.xls()`</a>.

The <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xls" target="_blank" rel="noopener noreferrer">`urbanpop.xls`</a> dataset is already available in your workspace. It's still comprised of three sheets, and has column names in the first row of each sheet.


**Instructions:**

* Finish the `read.xls()` call that reads data from the second sheet of `urbanpop.xls`: skip the first 50 rows of the sheet. Make sure to set `header` appropriately and that the country names are not imported as factors.
* Print the first 10 observations of `urban_pop` with `head()`.

**Solution:**

```{r,eval=TRUE}
# Column names for urban_pop
columns <- c("country", paste0("year_", 1967:1974))

# Finish the read.xls call
urban_pop <- read.xls("data/urbanpop.xls", sheet = 2,
                      skip = 50, header = F, stringsAsFactors = F,
                      col.names = columns)

# Print first 10 observation of urban_pop
head(urban_pop, n = 10)
```



## Work that Excel data!

Now that you can read in Excel data, let's try to clean and merge it. You already used the <a href="http://www.rdocumentation.org/packages/base/functions/cbind" target="_blank" rel="noopener noreferrer">`cbind()`</a> function some exercises ago. Let's take it one step further now.

The <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xls" target="_blank" rel="noopener noreferrer">`urbanpop.xls`</a> dataset is available in your working directory. The file still contains three sheets, and has column names in the first row of each sheet.


**Instructions:**

* Add code to read the data from the third sheet in `"urbanpop.xls"`. You want to end up with three data frames: `urban_sheet1`, `urban_sheet2` and `urban_sheet3`.
* Extend the `cbind()` call so that it also includes `urban_sheet3`. Make sure the first column of `urban_sheet2` and `urban_sheet3` are removed, so you don't have duplicate columns. Store the result in `urban`.
* Use <a href="http://www.rdocumentation.org/packages/stats/functions/na.fail" target="_blank" rel="noopener noreferrer">`na.omit()`</a> on the `urban` data frame to remove all rows that contain `NA` values. Store the cleaned data frame as `urban_clean`.
* Print a summary of `urban_clean` and assert that there are no more `NA` values.

**Solution:**

```{r,eval=TRUE}
# Add code to import data from all three sheets in urbanpop.xls
path <- "data/urbanpop.xls"
urban_sheet1 <- read.xls(path, sheet = 1, stringsAsFactors = FALSE)
urban_sheet2 <- read.xls(path, sheet = 2, stringsAsFactors = FALSE)
urban_sheet3 <- read.xls(path, sheet = 3, stringsAsFactors = FALSE)

# Extend the cbind() call to include urban_sheet3: urban
urban <- cbind(urban_sheet1, urban_sheet2[-1], urban_sheet3[-1])

# Remove all rows with NAs from urban: urban_clean
urban_clean <- na.omit(urban)

# Print out a summary of urban_clean
summary(urban_clean)
```


# 4. Reproducible Excel work with XLConnect
## Connect to a workbook

When working with `XLConnect`, the first step will be to load a workbook in your R session with <a href="http://www.rdocumentation.org/packages/XLConnect/functions/loadWorkbook" target="_blank" rel="noopener noreferrer">`loadWorkbook()`</a>; this function will build a "bridge" between your Excel file and your R session.

In this and the following exercises, you will continue to work with <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop.xlsx`</a>, containing urban population data throughout time. The Excel file is available in your current working directory.


**Instructions:**

* Load the `XLConnect` package using <a href="http://www.rdocumentation.org/packages/base/functions/library" target="_blank" rel="noopener noreferrer">`library()`</a>; it is already installed on DataCamp's servers.
* Use <a href="http://www.rdocumentation.org/packages/XLConnect/functions/loadWorkbook" target="_blank" rel="noopener noreferrer">`loadWorkbook()`</a> to build a connection to the `"urbanpop.xlsx"` file in R. Call the workbook `my_book`.
* Print out the class of `my_book`. What does this tell you?

**Solution:**

```{r,eval=TRUE}
# Load the XLConnect package
library("XLConnect")

# Build connection to urbanpop.xlsx: my_book
my_book <- loadWorkbook("data/urbanpop.xlsx")

# Print out the class of my_book
class(my_book)
```



## List and read Excel sheets

Just as `readxl` and `gdata`, you can use `XLConnect` to import data from Excel file into R.

To list the sheets in an Excel file, use <a href="http://www.rdocumentation.org/packages/XLConnect/functions/getSheets-methods" target="_blank" rel="noopener noreferrer">`getSheets()`</a>. To actually import data from a sheet, you can use <a href="http://www.rdocumentation.org/packages/XLConnect/functions/readWorksheet-methods" target="_blank" rel="noopener noreferrer">`readWorksheet()`</a>. Both functions require an XLConnect workbook object as the first argument.

You'll again be working with <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop.xlsx`</a>. The `my_book` object that links to this Excel file has already been created.


**Instructions:**

* Print out the sheets of the Excel file that `my_book` links to.
* Import the second sheet in `my_book` as a data frame. Print it out.

**Solution:**

```{r,eval=TRUE}
# Build connection to urbanpop.xlsx
my_book <- loadWorkbook("data/urbanpop.xlsx")

# List the sheets in my_book
getSheets(my_book)

# Import the second sheet in my_book
readWorksheet(my_book, "1967-1974")
```



## Customize readWorksheet

To get a clear overview about <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop.xlsx`</a> without having to open up the Excel file, you can execute the following code:


```{r}
my_book <- loadWorkbook("urbanpop.xlsx")
sheets <- getSheets(my_book)
all <- lapply(sheets, readWorksheet, object = my_book)
str(all)
```

Suppose we're only interested in urban population data of the years 1968, 1969 and 1970. The data for these years is in the columns 3, 4, and 5 of the second sheet. Only selecting these columns will leave us in the dark about the actual countries the figures belong to.


**Instructions:**

* Extend the `readWorksheet()` command with the `startCol` and `endCol` arguments to only import the columns 3, 4, and 5 of the second sheet.
* `urbanpop_sel` no longer contains information about the countries now. Can you write another `readWorksheet()` command that imports only the first column from the second sheet? Store the resulting data frame as `countries`.
* Use `cbind()` to paste together `countries` and `urbanpop_sel`, in this order. Store the result as `selection`.

**Solution:**

```{r,eval=TRUE}
# Build connection to urbanpop.xlsx
my_book <- loadWorkbook("data/urbanpop.xlsx")

# Import columns 3, 4, and 5 from second sheet in my_book: urbanpop_sel
urbanpop_sel <- readWorksheet(my_book, sheet = 2, startCol = 3, endCol = 5)

# Import first column from second sheet in my_book: countries
countries <- readWorksheet(my_book, sheet = 2, startCol = 1, endCol = 1)

# cbind() urbanpop_sel and countries together: selection
selection <- cbind(countries, urbanpop_sel)
```



## Add worksheet

Where `readxl` and `gdata` were only able to import Excel data, `XLConnect`'s approach of providing an actual interface to an Excel file makes it able to edit your Excel files from inside R. In this exercise, you'll create a new sheet. In the next exercise, you'll populate the sheet with data, and save the results in a new Excel file.

You'll continue to work with <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/urbanpop.xlsx" target="_blank" rel="noopener noreferrer">`urbanpop.xlsx`</a>. The `my_book` object that links to this Excel file is already available.


**Instructions:**

* Use <a href="http://www.rdocumentation.org/packages/XLConnect/functions/createSheet-methods" target="_blank" rel="noopener noreferrer">`createSheet()`</a>, to create a new sheet in `my_book`, named `"data_summary"`.
* Use <a href="https://www.rdocumentation.org/packages/XLConnect/topics/getSheets-methods" target="_blank" rel="noopener noreferrer">`getSheets()`</a> to verify that `my_book` now represents an Excel file with four sheets.

**Solution:**

```{r,eval=TRUE}
# Build connection to urbanpop.xlsx
my_book <- loadWorkbook("data/urbanpop.xlsx")

# Add a worksheet to my_book, named "data_summary"
createSheet(my_book, "data_summary")

# Use getSheets() on my_book
getSheets(my_book)
```



## Populate worksheet

The first step of creating a sheet is done; let's populate it with some data now! `summ`, a data frame with some summary statistics on the two Excel sheets is already coded so you can take it from there.


**Instructions:**

* Use <a href="http://www.rdocumentation.org/packages/XLConnect/functions/writeWorksheet-methods" target="_blank" rel="noopener noreferrer">`writeWorksheet()`</a> to populate the `"data_summary"` sheet with the `summ` data frame.
* Call <a href="http://www.rdocumentation.org/packages/XLConnect/functions/saveWorkbook-methods" target="_blank" rel="noopener noreferrer">`saveWorkbook()`</a> to store the adapted Excel workbook as a new file, `"summary.xlsx"`.

**Solution:**

```{r,eval=TRUE}
# Build connection to urbanpop.xlsx
my_book <- loadWorkbook("data/urbanpop.xlsx")

# Add a worksheet to my_book, named "data_summary"
createSheet(my_book, "data_summary")

# Create data frame: summ
sheets <- getSheets(my_book)[1:3]
dims <- sapply(sheets, function(x) dim(readWorksheet(my_book, sheet = x)), USE.NAMES = FALSE)
summ <- data.frame(sheets = sheets,
                   nrows = dims[1, ],
                   ncols = dims[2, ])

# Add data in summ to "data_summary" sheet
writeWorksheet(my_book, data = summ, sheet = "data_summary")

# Save workbook as summary.xlsx
saveWorkbook(my_book, "data/summary.xlsx")
```



## Renaming sheets

Come to think of it, `"data_summary"` is not an ideal name. As the summary of these excel sheets is always data-related, you simply want to name the sheet `"summary"`.

The code to build a connection to `"urbanpop.xlsx"` and create `my_book` is already provided for you. It refers to an Excel file with 4 sheets: the three data sheets, and the `"data_summary"` sheet.


**Instructions:**

* Use `renameSheet()` to rename the fourth sheet to `"summary"`.
* Next, call `getSheets()` on `my_book` to print out the sheet names.
* Finally, make sure to actually save the `my_book` object to a new Excel file, `"renamed.xlsx"`.

**Solution:**

```{r,eval=TRUE}
# Rename "data_summary" sheet to "summary"
renameSheet(my_book, "data_summary", "summary")

# Print out sheets of my_book
getSheets(my_book)

# Save workbook to "renamed.xlsx"
saveWorkbook(my_book, "data/renamed.xlsx")
```



## Removing sheets

After presenting the new Excel sheet to your peers, it appears not everybody is a big fan. Why summarize sheets and store the info in Excel if all the information is implicitly available? To hell with it, just remove the entire fourth sheet!


**Instructions:**

* Load the `XLConnect` package.
* Build a connection to `"renamed.xlsx"`, the Excel file that you've built in the previous exercise; it's available in your working directory. Store this connection as `my_book`.
* Use `removeSheet()` to remove the fourth sheet from `my_book`. The sheet name is `"summary"`. Recall that `removeSheet()` accepts either the index or the name of the sheet as the second argument.
* Save the resulting workbook, `my_book`, to a file `"clean.xlsx"`.

**Solution:**

```{r,eval=TRUE}
# Load the XLConnect package
library("XLConnect")

# Build connection to renamed.xlsx: my_book
my_book <- loadWorkbook("data/renamed.xlsx")

# Remove the fourth sheet
removeSheet(my_book, 4)

# Save workbook to "clean.xlsx"
saveWorkbook(my_book, "data/clean.xlsx")
```